import pandas as pd
import json
from sqlalchemy import create_engine, text
from sqlalchemy.exc import SQLAlchemyError
from app.config import settings
from app.core.logging import logger
from typing import Dict, Any

# --- CONFIGURATION ---
TABLE_NAME = 'agri_climate_data'
ENGINE = None 

# Expanded Mock Data for cross-domain synthesis (The Unified Data Store)
AGRI_CLIMATE_DATA = [
    {'State': 'Maharashtra', 'Year': 2017, 'Crop': 'Wheat', 'Production_MT': 1800, 'Rainfall_mm': 800, 'Is_Drought_Resistant': 0},
    {'State': 'Maharashtra', 'Year': 2018, 'Crop': 'Wheat', 'Production_MT': 1750, 'Rainfall_mm': 760, 'Is_Drought_Resistant': 0},
    {'State': 'Maharashtra', 'Year': 2019, 'Crop': 'Wheat', 'Production_MT': 2050, 'Rainfall_mm': 900, 'Is_Drought_Resistant': 0},
    {'State': 'Maharashtra', 'Year': 2019, 'Crop': 'Rice', 'Production_MT': 550, 'Rainfall_mm': 900, 'Is_Drought_Resistant': 0},
    {'State': 'Karnataka', 'Year': 2017, 'Crop': 'Wheat', 'Production_MT': 1100, 'Rainfall_mm': 450, 'Is_Drought_Resistant': 0},
    {'State': 'Karnataka', 'Year': 2018, 'Crop': 'Wheat', 'Production_MT': 1350, 'Rainfall_mm': 600, 'Is_Drought_Resistant': 0},
    {'State': 'Karnataka', 'Year': 2019, 'Crop': 'Wheat', 'Production_MT': 1400, 'Rainfall_mm': 610, 'Is_Drought_Resistant': 0},
    {'State': 'Karnataka', 'Year': 2019, 'Crop': 'Millet', 'Production_MT': 800, 'Rainfall_mm': 610, 'Is_Drought_Resistant': 1},
    {'State': 'Rajasthan', 'Year': 2017, 'Crop': 'Millet', 'Production_MT': 800, 'Rainfall_mm': 300, 'Is_Drought_Resistant': 1},
    {'State': 'Rajasthan', 'Year': 2018, 'Crop': 'Millet', 'Production_MT': 950, 'Rainfall_mm': 380, 'Is_Drought_Resistant': 1},
    {'State': 'Rajasthan', 'Year': 2019, 'Crop': 'Millet', 'Production_MT': 1000, 'Rainfall_mm': 400, 'Is_Drought_Resistant': 1},
    {'State': 'Bihar', 'Year': 2018, 'Crop': 'Rice', 'Production_MT': 2500, 'Rainfall_mm': 1200, 'Is_Drought_Resistant': 0},
    {'State': 'Bihar', 'Year': 2019, 'Crop': 'Rice', 'Production_MT': 1500, 'Rainfall_mm': 600, 'Is_Drought_Resistant': 0}, 
    {'State': 'Bihar', 'Year': 2019, 'Crop': 'Millet', 'Production_MT': 400, 'Rainfall_mm': 600, 'Is_Drought_Resistant': 1}, 
]

def get_engine():
    """Initializes and returns the SQLAlchemy engine for Postgres."""
    global ENGINE
    if ENGINE is None:
        try:
            # SQLAlchemy connects using the computed URL from config.py
            ENGINE = create_engine(settings.DATABASE_URL)
        except Exception as e:
            logger.error(f"Failed to create PostgreSQL engine: {e}")
            return None
    return ENGINE

def setup_mock_database() -> bool:
    """Initializes the PostgreSQL database with mock data on startup."""
    engine = get_engine()
    if engine is None:
        return False
        
    try:
        df = pd.DataFrame(AGRI_CLIMATE_DATA)
        
        # Use Pandas to write the DataFrame directly to the PostgreSQL table
        with engine.connect() as connection:
            df.to_sql(TABLE_NAME, connection, if_exists='replace', index=False)
            connection.commit()
            
        logger.info(f"PostgreSQL table '{TABLE_NAME}' loaded with {len(df)} mock records.")
        return True
    
    except SQLAlchemyError as e:
        logger.error(f"Error setting up PostgreSQL database: {e}")
        return False
    except Exception as e:
        logger.error(f"Unexpected error during mock DB setup: {e}")
        return False
    
def get_db_schema() -> str:
    """Returns the SQL schema for the LLM's context (Postgres dialect)."""
    return f"""
CREATE TABLE {TABLE_NAME} (
    "State" VARCHAR,
    "Year" INTEGER,
    "Crop" VARCHAR,
    "Production_MT" REAL,
    "Rainfall_mm" REAL,
    "Is_Drought_Resistant" INTEGER 
    -- 1 if crop requires little water, 0 otherwise.
);
-- Contains unified data on crop production and corresponding annual rainfall by state and year.
"""

def execute_mock_sql(query: str) -> str:
    """
    The LLM's primary tool. Executes a read-only SQL query against Postgres. 
    
    :param query: The SQL SELECT query generated by the LLM (must be PostgreSQL syntax).
    :return: The query result formatted as a JSON string, or an error message.
    """
    engine = get_engine()
    if engine is None:
        return json.dumps({"error": "PostgreSQL connection failed. Check config and server status."})
        
    try:
        # Security check: only allow SELECT statements
        if not query.strip().upper().startswith("SELECT"):
            return json.dumps({"error": "Only SELECT queries are allowed."})
            
        # Execute the query using Pandas read_sql 
        results_df = pd.read_sql(text(query), engine)
        
        # Convert DataFrame rows to list of dictionaries for the LLM
        results = results_df.to_dict(orient='records')
        
        # Truncate large results to prevent context window overflow
        if len(results) > 50:
             return json.dumps(results[:50], indent=2) + f"\n... (Truncated to first 50 of {len(results)} records)"

        return json.dumps(results, indent=2)
    
    except SQLAlchemyError as e:
        return json.dumps({"error": f"PostgreSQL query error: {e.__class__.__name__}: {e}", "query_attempted": query})
    except Exception as e:
        return json.dumps({"error": f"An unexpected error occurred: {e}", "query_attempted": query})

# The actual tool object for the Gemini Agent
SQL_TOOL = execute_mock_sql
